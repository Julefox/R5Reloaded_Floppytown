global function ClWeaponStatus_Init
global function ClWeaponStatus_GetWeaponHudRui
global function ClWeaponStatus_RefreshWeaponStatus
global function ClWeaponStatus_UpdateShowButtonHint
global function ClWeaponStatus_RefreshWeaponInfo

global function AddCallback_OnInitWeaponStatusRuis
global function AddCallback_OnWeaponStatusUpdate
global function AddCallback_OnPrimaryWeaponStatusUpdate

global function TrackPrimaryWeaponEnabled

global function GetHudDefaultVisibility
global function WeaponStatusSetWeaponInspect
global function UltimateWeaponStateSet
global function UpdateHudDataForMainWeapons
global function ServerCallback_UpdateHudWeaponData

global function NotifyReloadAttemptButNoReserveAmmo

global function UpdateWeaponStatusOnBindingChange

#if R5DEV
global function DEV_TestUltimateStates
global function GetUltimateWeaponState
#endif //DEV

global enum eUltimateState
{
	CHARGING    // weapon is counting down
	READY        // ready to be used - pulling out the grenade would still keep it in this state since it can be aborted.
	ACTIVE        // weapon has been activated
}

struct
{
	var    ammo_status_hint
	var    ability_left_hud
	var    ability_center_hud
	var    ability_right_hud
	var    weapon_hud_rui
	int    ultimateVideoChannel
	entity lastSelectedPrimaryWeapon

	bool[6] slotVisible = [true, true, true, true, true, true]
	bool    ammo_counter_visible = true

	array<void functionref( entity, var, int )> weaponStatusUpdateCallbacks
	array<void functionref( entity, var )>      primaryWeaponStatusUpdateCallbacks

	#if R5DEV
		bool devTestingUltimateStates
	#endif //DEV
} file

const float NO_RESERVE_AMMO_DISPLAY_TIME = 2.0

void function ClWeaponStatus_Init()
{
	AddCallback_OnClientScriptInit( ClWeaponStatus_AddClient )
	AddCallback_OnSelectedWeaponChanged( OnSelectedWeaponChanged )

	AddCallback_OnPlayerLifeStateChanged( OnLifeStateChanged )
	AddCallback_PlayerClassChanged( OnPlayerClassChanged )

	AddCallback_OnPlayerAddWeaponMod( OnPlayerAddWeaponMod )
	AddCallback_OnPlayerRemoveWeaponMod( OnPlayerRemoveWeaponMod )

	AddCallback_KillReplayEnded( OnKillReplayEnded )

	AddCallback_OnCommsMenuStateChanged( AmmoStatusHint_OnCommsMenu )

	if ( GetCurrentPlaylistVarBool( "hud_ultimate_ready_video", false ) )
	{
		AddCallback_OnWeaponStatusUpdate( UltimateWeaponStatusUpdate )
		RegisterSignal( "ultimate_video_finished" )
		file.ultimateVideoChannel = ReserveVideoChannel( UltimateReadyVideoFinished )
	}

	RegisterSignal( "EndTrackOffhandWeaponSlot" )
	RegisterSignal( "ultimate_weapon_status_changed" )
}

void function UpdateWeaponStatusOnBindingChange()
{
	bool weaponSelectKeysBound = GetKeyCodeForBinding( "weaponSelectPrimary0" ) != -1 && GetKeyCodeForBinding( "weaponSelectPrimary1" ) != -1
	var weaponRui = ClWeaponStatus_GetWeaponHudRui( GetLocalViewPlayer() )
	if ( weaponRui != null )
		RuiSetBool( weaponRui, "weaponSelectKeysBoundForPC", weaponSelectKeysBound )
}

void function AddCallback_OnPrimaryWeaponStatusUpdate( void functionref( entity, var ) func )
{
	Assert( !file.primaryWeaponStatusUpdateCallbacks.contains( func ) )
	file.primaryWeaponStatusUpdateCallbacks.append( func )
}


void function AddCallback_OnWeaponStatusUpdate( void functionref( entity, var, int ) func )
{
	Assert( !file.weaponStatusUpdateCallbacks.contains( func ) )
	file.weaponStatusUpdateCallbacks.append( func )
}

void function ClWeaponStatus_RefreshWeaponStatus( entity player )
{
	if ( !IsValid( player ) )
		return

	if ( !IsValid( GetLocalViewPlayer() ) )
		return

	InitWeaponStatusRuis( GetLocalViewPlayer() )
}


var function ClWeaponStatus_GetWeaponHudRui( entity player, entity weapon = null )
{
	if ( weapon == null )
		return file.weapon_hud_rui

	var index = weapon.GetWeaponInfoFileKeyField( "offhand_default_inventory_slot" )
	//int index = weapon.GetWeaponSettingInt( eWeaponVar.offhand_default_inventory_slot ) // TODO: Will always return int with default of 0, but this would match OFFHAND_RIGHT

	if ( index == null )
		return file.weapon_hud_rui

	expect int( index )

	return GetRuiForIndex( player, index )
}


void function ClWeaponStatus_AddClient( entity player )
{
	{
		var rui = CreateCockpitPostFXRui( $"ui/ammo_status_hint.rpak", HUD_Z_BASE )
		RuiTrackFloat( rui, "ammoFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
		RuiTrackFloat( rui, "remainingAmmoFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION )
		RuiTrackFloat( rui, "readyToFireFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
		RuiTrackFloat( rui, "reloadingFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_RELOAD_FRACTION )
		RuiTrackFloat( rui, "minAmmoToFireFrac", GetLocalClientPlayer(), RUI_TRACK_WEAPON_CLIP_MIN_AMMO_FRACTION )
		RuiTrackBool( rui, "canShowReloadHint", null, RUI_TRACK_CAN_SHOW_RELOAD_PROMPT )

		file.ammo_status_hint = rui
	}

	{
		// tactical
		var rui = CreateCockpitPostFXRui( $"ui/tactical_ability_hud.rpak", HUD_Z_BASE )
		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		file.ability_center_hud = rui
	}

	{
		// ultimate ablility
		var rui
		if ( GetCurrentPlaylistVarBool( "hud_ultimate_ready_video", false ) )
			rui = CreateCockpitPostFXRui( $"ui/ultimate_ability_hud.rpak", HUD_Z_BASE )
		else
			rui = CreateCockpitPostFXRui( $"ui/ability_hud.rpak", HUD_Z_BASE )

		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		RuiTrackInt( rui, "ultimateCredits", player, RUI_TRACK_SCRIPT_NETWORK_VAR_INT, GetNetworkedVariableIndex( "ultimateCredits" ) )
		file.ability_left_hud = rui
	}

	{
		// not used by human-sized players, might be use by titans?
		var rui = CreateCockpitRui( $"ui/ability_hud.rpak", HUD_Z_BASE )
		RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
		RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
		file.ability_right_hud = rui
	}

	var rui = CreateCockpitPostFXRui( SURVIVAL_HUD_WEAPON_RUI, HUD_Z_BASE )
	RuiTrackFloat( rui, "reviveEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "reviveEndTime" ) )
	RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )
	file.weapon_hud_rui = rui
	UpdateWeaponStatusOnBindingChange()
}


void function ClWeaponStatus_RefreshWeaponInfo()
{
	// this gets called when a weapons attachments change
	entity player       = GetLocalViewPlayer()
	entity activeWeapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )

	if ( !IsWeaponInPrimarySlot( player, activeWeapon ) )
	{
		// if the active weapon is a primary weapon we don't need to update.
		UpdateHudDataForMainWeapons( player, null )
	}
}

bool function IsWeaponInPrimarySlot( entity player, entity weapon )
{
	entity weaponInSlot0 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 )
	entity weaponInSlot1 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 )

	bool isInPrimarySlot = IsValid( weapon ) && (weapon == weaponInSlot0 || weapon == weaponInSlot1)
	return isInPrimarySlot
}

void function NotifyReloadAttemptButNoReserveAmmo()
{
	RuiSetFloat( file.ammo_status_hint, "displayNoReserveAmmoEndTime", Time() + NO_RESERVE_AMMO_DISPLAY_TIME )
}

void function OnSelectedWeaponChanged( entity selectedWeapon )
{
	entity player = GetLocalViewPlayer()

	if ( !IsValid( selectedWeapon ) )
	{
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )
		RuiSetBool( file.weapon_hud_rui, "isVisible", false )
		return
	}

	if ( selectedWeapon.IsWeaponOffhand() )
	{
		RuiSetBool( file.weapon_hud_rui, "isMainWeaponSelected", false )
		bool isOffhandUsesAmmoStatus = selectedWeapon.GetWeaponSettingBool( eWeaponVar.offhand_uses_hud_ammo_status )

		if ( !isOffhandUsesAmmoStatus )
			return
	}

	UpdateHudDataForMainWeapons( player, selectedWeapon )
	UpdateDpadHud( player )

	foreach ( func in file.primaryWeaponStatusUpdateCallbacks )
		func( selectedWeapon, file.weapon_hud_rui )
}

void function AmmoStatusHint_OnCommsMenu( bool menuOpened )
{
	// don't show ammo status hints when the comms menu is open.
	RuiSetVisible( file.ammo_status_hint, !menuOpened )
}

void function ServerCallback_UpdateHudWeaponData( entity weaponFromServer )
{
	entity player = GetLocalViewPlayer()
	entity weapon = player.GetSelectedWeapon( eActiveInventorySlot.mainHand )
	if ( !IsValid( weapon ) )
		weapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
	UpdateHudDataForMainWeapons( player, weapon )
}

void function UpdateHudDataForMainWeapons( entity player, entity selectedWeapon )
{
	var rui = file.weapon_hud_rui

	bool isOffhandUsesAmmoStatus = IsValid( selectedWeapon ) && selectedWeapon.GetWeaponSettingBool( eWeaponVar.offhand_uses_hud_ammo_status )

	entity weaponInSlot0 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_0 )
	entity weaponInSlot1 = player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_1 )
	bool noWeapon        = !IsValid( weaponInSlot0 ) && !IsValid( weaponInSlot1 ) && !isOffhandUsesAmmoStatus
	bool isMainWeapon    = IsValid( selectedWeapon ) && (selectedWeapon == weaponInSlot0 || selectedWeapon == weaponInSlot1 )
	bool isTitan =			player.IsTitan()

	if ( noWeapon || isTitan )
	{
		ClearRuiWeaponData( rui, isTitan )
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )    //
		return
	}

	if ( !isOffhandUsesAmmoStatus )
	{
		RuiSetBool( rui, "noMainWeaponEquiped", false )
		RuiSetBool( rui, "isMainWeaponSelected", isMainWeapon )
	}

	// Weapon status:

	int activeWeaponTab = -1

	if ( isMainWeapon )
	{
		// if we are using one of the main weapons set the tab to the one that is being selected
		if ( selectedWeapon == weaponInSlot0 && IsValid( weaponInSlot0 ) )
			activeWeaponTab = 0
		if ( selectedWeapon == weaponInSlot1 && IsValid( weaponInSlot1 ) )
			activeWeaponTab = 1
	}
	else if ( !IsValid( file.lastSelectedPrimaryWeapon ) )
	{
		// if we are not using one of the main weapons and the old selection is invalid. set the tab to the one that is valid, and update the rui tracks
		if ( IsValid( weaponInSlot0 ) )
		{
			InitWeaponRuiTracks( rui, player, weaponInSlot0 )
			file.lastSelectedPrimaryWeapon = weaponInSlot0
			activeWeaponTab = 0
		}
		else if ( IsValid( weaponInSlot1 ) )
		{
			InitWeaponRuiTracks( rui, player, weaponInSlot1 )
			file.lastSelectedPrimaryWeapon = weaponInSlot1
			activeWeaponTab = 1
		}
	}

	UpdateRUIWeaponData( player, rui, weaponInSlot0, 0, activeWeaponTab == 0 )
	UpdateRUIWeaponData( player, rui, weaponInSlot1, 1, activeWeaponTab == 1 )

	if ( isMainWeapon )
	{
		InitWeaponRuiTracks( rui, player, selectedWeapon )
		file.lastSelectedPrimaryWeapon = selectedWeapon

		float lowAmmoFrac = selectedWeapon.GetWeaponSettingFloat( eWeaponVar.low_ammo_fraction )
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", lowAmmoFrac )

		bool canShowWeaponCycleHint = CanShowWeaponCycleHint( selectedWeapon, weaponInSlot0, weaponInSlot1 )
		RuiSetBool( file.ammo_status_hint, "canShowWeaponCycleHint", canShowWeaponCycleHint )

		bool canShowReloadHint = CanShowReloadHint()
		RuiSetBool( file.ammo_status_hint, "canShowReloadHint", canShowReloadHint )
	}
	else if ( isOffhandUsesAmmoStatus )
	{
		float lowAmmoFrac = selectedWeapon.GetWeaponSettingFloat( eWeaponVar.low_ammo_fraction )
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", lowAmmoFrac )
	}
	else
	{
		// don't show ammo hints if you are not using a weapon in your first two primary slots.
		RuiSetFloat( file.ammo_status_hint, "lowAmmoFrac", 0.0 )

		// update modes on the last selected primary weapon since they might have changed
		if ( IsWeaponInPrimarySlot( player, file.lastSelectedPrimaryWeapon ) )
			UpdateModsOnSurvivalWeaponRui( rui, file.lastSelectedPrimaryWeapon )
	}
}


void function ClearRuiWeaponData( var rui, bool isTitan )
{
	RuiSetInt( rui, "sightTier", 0 )
	RuiSetBool( rui, "sightAllowed", false )
	RuiSetInt( rui, "barrelTier", 0 )
	RuiSetBool( rui, "barrelAllowed", false )
	RuiSetInt( rui, "magTier", 0 )
	RuiSetBool( rui, "magAllowed", false )
	RuiSetInt( rui, "gripTier", 0 )
	RuiSetBool( rui, "gripAllowed", false )
	RuiSetInt( rui, "hopupTier", 0 )
	RuiSetBool( rui, "hopupAllowed", false )
	RuiSetInt( rui, "weaponTier", 0 )

	RuiSetFloat( rui, "maxMagAmmo", 0 )
	RuiSetFloat( rui, "maxAmmo", 0 )
	RuiSetFloat( rui, "clipAmmoFrac", 0 )
	RuiSetFloat( rui, "remainingAmmoFrac", 0 )
	RuiSetFloat( rui, "lifetimeShots", 0 )
	RuiSetFloat( rui, "ammoRegenRate", 0 )

	RuiSetBool( rui, "ammoPoolVisible", false )

	RuiSetImage( rui, "hudIcon", $"" )

	RuiSetFloat3( rui, "ammoColor", SrgbToLinear( <0.5, 0.5, 0.5> ) )
	RuiSetImage( rui, "ammoIcon", $"rui/hud/gametype_icons/survival/sur_ammo_blank" )

	RuiSetInt( rui, "weaponTabSelected", -1 )
	RuiSetBool( rui, "isMainWeaponSelected", false )
	RuiSetBool( rui, "noMainWeaponEquiped", true )
	RuiSetString( rui, "weaponNameTab0", "" )
	RuiSetString( rui, "weaponNameTab1", "" )

	ClearWeaponToggleHUD()

	RuiSetBool( rui, "isVisible", (GetHudDefaultVisibility() && file.ammo_counter_visible && !isTitan) )
}


void function UpdateRUIWeaponData( entity player, var rui, entity weapon, int tabIndex, bool selected )
{
	LootData weaponData = SURVIVAL_GetLootDataFromWeapon( weapon )

	if ( selected )
	{
		PrimaryWeapon_UpdateFireSelectHUD( weapon )
		UpdateModsOnSurvivalWeaponRui( rui, weapon )

		RuiSetBool( rui, "isVisible", (GetHudDefaultVisibility() && file.ammo_counter_visible && !player.IsTitan()) )
		RuiSetBool( rui, "isTitan", player.IsTitan() )
		RuiSetBool( rui, "isWeaponAmped", weapon.GetWeaponSettingBool( eWeaponVar.is_burn_mod ) )

		RuiSetInt( rui, "weaponTabSelected", tabIndex )
		RuiSetString( rui, "skinName", "" )
		RuiSetInt( rui, "skinTier", 0 )
	}

	if ( IsValid( weapon ) )
	{
		string weaponName = GetWeaponInfoFileKeyField_GlobalString( weapon.GetWeaponClassName(), "shortprintname" )
		RuiSetString( rui, "weaponNameTab" + tabIndex, weaponName )
		if ( selected )
			RuiSetString( rui, "weaponName", weaponName )

		if ( SURVIVAL_Loot_IsRefValid( weaponData.ref ) )
		{
			if ( selected )
			{
				RuiSetInt( rui, "weaponTier", weaponData.tier )

				if ( weaponName != "" )
				{
					if ( weaponData.lootType == eLootType.MAINWEAPON && weapon.GetGrade() > 0 )
					{
						ItemFlavor weaponSkin = GetItemFlavorByNetworkIndex_DEPRECATED( weapon.GetGrade() )
						RuiSetString( rui, "skinName", ItemFlavor_GetLongName( weaponSkin ) )
						if ( ItemFlavor_HasQuality( weaponSkin ) )
							RuiSetInt( rui, "skinTier", ItemFlavor_GetQuality( weaponSkin ) + 1 )
					}
				}
			}

			vector ammoColor  = SrgbToLinear( <0.5, 0.5, 0.5> )
			asset ammoIcon = weaponData.fakeAmmoIcon == $"" ? $"rui/hud/gametype_icons/survival/sur_ammo_unique" : weaponData.fakeAmmoIcon
			bool isLegendary = weaponData.tier >= 4

			if ( weaponData.ammoType != "" )
			{
				LootData ammoData = SURVIVAL_Loot_GetLootDataByRef( weaponData.ammoType )
				if ( weaponData.ammoType in ammoColors && weaponData.tier < 4 )
					ammoColor = SrgbToLinear( ammoColors[weaponData.ammoType] )
				else if ( weaponData.tier == 4)
					ammoColor = SrgbToLinear( AMMO_LEGENDARY_COLOR )

				if ( ammoData.hudIcon != $"" )
					ammoIcon = ammoData.hudIcon
			}

			if ( isLegendary )
			{
				ammoColor = SrgbToLinear( AMMO_LEGENDARY_COLOR )
			}

			RuiSetFloat3( rui, "ammoColorTab" + tabIndex, ammoColor )
			if ( selected )
			{
				RuiSetFloat3( rui, "ammoColor", ammoColor )
				RuiSetImage( rui, "ammoIcon", ammoIcon )
				RuiSetBool( rui, "isLegendary", isLegendary )
			}
		}
	}
	else
	{
		RuiSetString( rui, "weaponNameTab" + tabIndex, "" )
		RuiSetFloat3( rui, "ammoColorTab" + tabIndex, <0.0, 0.0, 0.0> )
		if ( selected )
		{
			RuiSetImage( rui, "ammoIcon", $"" )
			RuiSetFloat3( rui, "ammoColor", <0.0, 0.0, 0.0> )
		}
	}
}


void function PrimaryWeapon_UpdateFireSelectHUD( entity weapon )
{
	if ( !IsValid( weapon ) )
	{
		ClearWeaponToggleHUD()
		return
	}

	// traditional single/burst/auto select
	if ( WeaponHasFireModeSelect( weapon ) )
	{
		bool isAltFire = WeaponIsUsingAltFireMode( weapon )

		if ( IsWeaponInSingleShotMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_shot", "#FIRE_MODE_SINGLE", true, isAltFire )
		}
		else if ( IsWeaponInBurstMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/burst", "#FIRE_MODE_BURST", true, isAltFire )
		}
		else if ( IsWeaponInAutomaticMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_AUTO", true, isAltFire )
		}
		else
		{
			ClearWeaponToggleHUD()
		}
	}
	// special fire selects for other weapons and abilities
	else if ( DoesModExist( weapon, "vertical_firestar" ) )
	{
		if ( weapon.HasMod( "vertical_firestar" ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/akimbo", "#FIRE_MODE_LINE", true )
		}
		else
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_gun", "#FIRE_MODE_WALL", true )
		}
	}
	else if ( DoesModExist( weapon, "double_link_mod" ) )
	{
		if ( weapon.HasMod( "double_link_mod" ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/akimbo", "#FIRE_MODE_SPLIT", true )
		}
		else
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_gun", "#FIRE_MODE_COMBINED", true )
		}
	}
	else if ( DoesModExist( weapon, "akimbo" ) )
	{
		if ( weapon.HasMod( "akimbo" ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/akimbo", "#FIRE_MODE_AKIMBO", true )
		}
		else
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_gun", "#FIRE_MODE_SINGLE", true )
		}
	}
	else
	{
		if ( IsWeaponInSingleShotMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/single_shot", "#FIRE_MODE_SINGLE_ONLY", false )
		}
		else if ( IsWeaponInBurstMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/burst", "#FIRE_MODE_BURST_ONLY", false )
		}
		else if ( IsWeaponInAutomaticMode( weapon ) )
		{
			SetWeaponToggleHUD( $"rui/hud/weapon_toggle/automatic", "#FIRE_MODE_AUTO_ONLY", false )
		}
		else
		{
			ClearWeaponToggleHUD()
		}
	}
}


const table<string, string> ruiAttachmentAllowedArgs = {
	barrel = "barrelAllowed"
	grip = "gripAllowed"
	mag = "magAllowed"
	sight = "sightAllowed"
	hopup = "hopupAllowed"
}

const table<string, string> ruiAttachmentTierArgs = {
	barrel = "barrelTier"
	grip = "gripTier"
	mag = "magTier"
	sight = "sightTier"
	hopup = "hopupTier"
}

const table<string, string> ruiAttachmentIconArgs = {
	barrel = "barrelIcon"
	grip = "gripIcon"
	mag = "magIcon"
	sight = "sightIcon"
	hopup = "hopupIcon"
}

void function UpdateModsOnSurvivalWeaponRui( var rui, entity weapon )
{
	LootData weaponData

	if ( weapon.GetNetworkedClassName() == "prop_survival" )
		weaponData = SURVIVAL_Loot_GetLootDataByIndex( weapon.GetSurvivalInt() )
	else
		weaponData = SURVIVAL_GetLootDataFromWeapon( weapon )

	string weaponRef = weaponData.ref

	if ( !SURVIVAL_Loot_IsRefValid( weaponData.ref ) )
	{
		array<string> attachments = GetAllAttachmentPoints()
		foreach ( attachmentName in attachments )
		{
			RuiSetBool( rui, ruiAttachmentAllowedArgs[attachmentName], false )
			RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], 0 )
			RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], $"" )
		}
		return
	}

	array<string> attachments = GetAllAttachmentPoints()
	array<string> mods

	bool isAttachmentLockedWeapon = SURVIVAL_Weapon_IsAttachmentLocked( weaponRef )

	foreach ( attachmentName in attachments )
	{
		Assert( attachmentName in ruiAttachmentAllowedArgs )
		Assert( attachmentName in ruiAttachmentTierArgs )
		Assert( attachmentName in ruiAttachmentIconArgs )

		if ( AttachmentPointSupported( attachmentName, weaponRef ) )
		{
			RuiSetBool( rui, ruiAttachmentAllowedArgs[attachmentName], true )

			string mod = GetInstalledWeaponAttachment( weapon, attachmentName )
			if ( SURVIVAL_Loot_IsRefValid( mod ) )
			{
				LootData data = SURVIVAL_Loot_GetLootDataByRef( mod )
				if ( isAttachmentLockedWeapon )
					RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], weaponData.tier )
				else
					RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], data.tier )
				RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], data.hudIcon )
			}
			else
			{
				string attachmentStyle = GetAttachmentPointStyle( attachmentName, weaponRef )

				RuiSetInt( rui, ruiAttachmentTierArgs[attachmentName], 0 )
				RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], emptyAttachmentSlotImages[attachmentStyle] )
			}
		}
		else
		{
			RuiSetBool( rui, ruiAttachmentAllowedArgs[attachmentName], false )
			RuiSetImage( rui, ruiAttachmentIconArgs[attachmentName], $"" )
		}
	}
}


void function ClearWeaponToggleHUD()
{
	var rui = ClWeaponStatus_GetWeaponHudRui( GetLocalViewPlayer() )
	if ( rui != null )
	{
		RuiSetString( rui, "fireMode", "" )
		RuiSetBool( rui, "hasFireMode", false )
	}
}


bool function WeaponHasFireModeSelect( entity weapon )
{
	if ( DoesModExist( weapon, "hopup_selectfire" ) )
		return IsModActive( weapon, "hopup_selectfire" )
	else if ( DoesModExist( weapon, "hopup_highcal_rounds" ) && IsModActive( weapon, "hopup_highcal_rounds" ))
		return true
	else if ( DoesModExist( weapon, "hopup_double_tap" ) && IsModActive( weapon, "hopup_double_tap" ) )
		return true
	else if ( DoesModExist( weapon, "altfire" ) )
		return true

	return false
}


bool function WeaponIsUsingAltFireMode( entity weapon )
{
	if ( DoesModExist( weapon, "hopup_highcal_rounds" ) && IsModActive( weapon, "hopup_highcal_rounds" ) )
		return IsModActive( weapon, "altfire_highcal" )
	else if ( DoesModExist( weapon, "hopup_double_tap" ) && IsModActive( weapon, "hopup_double_tap" ) )
		return IsModActive( weapon, "altfire_double_tap" )
	if ( DoesModExist( weapon, "altfire" ) )
		return IsModActive( weapon, "altfire" )
	return false
}


void function SetWeaponToggleHUD( asset icon, string modeName, bool hasFireMode, bool isAltFire = true )
{
	var rui = ClWeaponStatus_GetWeaponHudRui( GetLocalViewPlayer() )
	if ( rui != null )
	{
		RuiSetBool( rui, "hasFireMode", hasFireMode )
		RuiSetString( rui, "fireMode", modeName )
		RuiSetImage( rui, "fireModeIcon", icon )
		RuiSetBool( rui, "isAltFire", isAltFire )
	}
}


void function UpdateFireSelectHint( entity player, entity weapon, string mod )
{
	string message = ""
	if ( IsWeaponInSingleShotMode( weapon ) )
		message = "#FIRE_MODE_SINGLE"
	else if ( IsWeaponInBurstMode( weapon ) )
		message = "#FIRE_MODE_BURST"
	else if ( IsWeaponInAutomaticMode( weapon ) )
		message = "#FIRE_MODE_AUTO"

	if ( message != "" )
		AnnouncementMessageRight( player, Localize( "#FIRE_MODE_COLON", Localize( message ) ), "", <1, 1, 1>, $"", 1.0 )
}


void function OnPlayerAddWeaponMod( entity player, entity weapon, string mod )
{
	if ( ( mod == "altfire" || mod == "altfire_highcal" || mod == "altfire_double_tap" ) && WeaponHasFireModeSelect( weapon ) )
		UpdateFireSelectHint( player, weapon, mod )

	OnSelectedWeaponChanged( weapon )
}


void function OnPlayerRemoveWeaponMod( entity player, entity weapon, string mod )
{
	if ( ( mod == "altfire" || mod == "altfire_highcal" || mod == "altfire_double_tap" ) && WeaponHasFireModeSelect( weapon ) )
		UpdateFireSelectHint( player, weapon, mod )

	OnSelectedWeaponChanged( weapon )
}


bool function CanShowWeaponCycleHint( entity selectedWeapon, entity weaponInSlot0, entity weaponInSlot1 )
{
	if ( !IsValid( selectedWeapon ) )
		return false

	if ( selectedWeapon.ShouldAutoCycleWhenOutOfAmmo() )
		return false  // it'll happen automatically

	bool haveAnotherValidPrimary =  ((IsValid( weaponInSlot0 ) && (selectedWeapon != weaponInSlot0)) || (IsValid( weaponInSlot1 ) && (selectedWeapon != weaponInSlot1)))
	if ( !haveAnotherValidPrimary )
		return true

	return false
}


bool function CanShowReloadHint()
{
	entity localViewPlayer = GetLocalViewPlayer()
	if ( !IsValid( localViewPlayer ) )
		return false

	int gamePadUseScheme = GetConVarInt( "gamepad_use_type" )
	entity useEnt        = localViewPlayer.GetUsePromptEntity()
	if ( (gamePadUseScheme == eGamepadUseSchemeType.TAP_TO_USE_TAP_TO_RELOAD) && IsValid( useEnt ) )
		return false

	if ( (gamePadUseScheme == eGamepadUseSchemeType.TAP_TO_USE_HOLD_TO_RELOAD) && IsValid( useEnt ) )
		return false

	return true
}


void function WeaponStatusSetWeaponInspect( bool inspect )
{
	RuiSetBool( file.ability_left_hud, "weaponInspect", inspect )
	RuiSetBool( file.ability_center_hud, "weaponInspect", inspect )
	RuiSetBool( file.ability_right_hud, "weaponInspect", inspect )
	RuiSetBool( file.weapon_hud_rui, "weaponInspect", inspect )
	array<var> additionalWeaponInspectRuis
	additionalWeaponInspectRuis.append( GetCryptoAnimatedTacticalRui() )
	additionalWeaponInspectRuis.append( GetBubbleBunkerRui() )
	foreach ( rui in additionalWeaponInspectRuis )
	{
		if ( rui != null )
			RuiSetBool( rui, "weaponInspect", inspect )
	}
}


void function InitWeaponRuiTracks( var rui, entity player, entity weapon )
{
	RuiTrackFloat( rui, "maxMagAmmo", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_MAX )
	RuiTrackFloat( rui, "maxAmmo", weapon, RUI_TRACK_WEAPON_AMMO_MAX )
	RuiTrackFloat( rui, "clipAmmoFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )
	RuiTrackFloat( rui, "remainingAmmoFrac", weapon, RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION )
	RuiTrackFloat( rui, "lifetimeShots", weapon, RUI_TRACK_WEAPON_LIFETIME_SHOTS )
	RuiTrackFloat( rui, "ammoRegenRate", weapon, RUI_TRACK_WEAPON_AMMO_REGEN_RATE )
	RuiTrackFloat( rui, "bleedoutEndTime", player, RUI_TRACK_SCRIPT_NETWORK_VAR, GetNetworkedVariableIndex( "bleedoutEndTime" ) )

	RuiSetBool( rui, "ammoPoolVisible", weapon.GetWeaponSettingBool( eWeaponVar.uses_ammo_pool ) )

	RuiTrackImage( rui, "hudIcon", weapon, RUI_TRACK_WEAPON_HUD_ICON )
}


void function OnPlayerClassChanged( entity player )
{
	if ( player != GetLocalViewPlayer() )
		return

	InitWeaponStatusRuis( player )
}

void function OnLifeStateChanged( entity player, int oldLifeState, int newLifeState )
{
	if ( player != GetLocalViewPlayer() )
		return

	if ( newLifeState != LIFE_ALIVE )
		return

	UltimateWeaponStateSet( eUltimateState.CHARGING )
	InitWeaponStatusRuis( player )
}


void function OnKillReplayEnded()
{
	entity player = GetLocalViewPlayer()

	InitWeaponStatusRuis( player )
}


void function UpdateOffhandRuis( entity player )
{
	UpdateOffhandRuiVisibility( file.ability_left_hud, "%offhand1%" )
	var cryptoTacticalRui = GetCryptoAnimatedTacticalRui()
	if ( cryptoTacticalRui != null )
		UpdateOffhandRuiVisibility( cryptoTacticalRui, "%offhand1%" )

	if ( !player.IsTitan() )
	{
		UpdateOffhandRuiVisibility( file.ability_center_hud, "%offhand0%" )
		UpdateOffhandRuiVisibility( file.ability_right_hud, "%offhand2%" )
	}

	// need to recreate this since RuiTrackInt cannot be undone with RuiSetInt
	//RuiDestroy( file.dpad_left_hud )
	//var rui = CreateCockpitRui( $"ui/inventory_hud.rpak" )
	//RuiSetInt( rui, "xPos", 1 )
	//RuiSetInt( rui, "yPos", 1 )
	//file.dpad_left_hud = rui
	//UpdateOffhandRuiVisibility( file.dpad_left_hud, "%offhand4%" )
}

array<void functionref( entity )> s_callbacks_OnInitWeaponStatusRuis
void function AddCallback_OnInitWeaponStatusRuis( void functionref( entity ) func )
{
	Assert( !s_callbacks_OnInitWeaponStatusRuis.contains( func ) )
	s_callbacks_OnInitWeaponStatusRuis.append( func )
}

void function InitWeaponStatusRuis( entity player )
{
	player.Signal( "EndTrackOffhandWeaponSlot" )

	foreach( func in s_callbacks_OnInitWeaponStatusRuis )
		func( player )

	UpdateOffhandRuis( player )
	thread TrackPrimaryWeaponEnabled( player, file.ammo_status_hint, "EndTrackOffhandWeaponSlot" )

	if ( !player.IsTitan() )
	{
		thread TrackOffhandWeaponSlot( player, file.ability_center_hud, OFFHAND_LEFT )
		thread TrackOffhandWeaponSlot( player, file.ability_left_hud, OFFHAND_INVENTORY )
	}
}


void function UpdateOffhandRuiVisibility( var rui, string hintText )
{
	if ( GetConVarInt( "hud_setting_showButtonHints" ) != 0 )
		RuiSetString( rui, "hintText", hintText )
	else
		RuiSetString( rui, "hintText", "" )
}


void function TrackPrimaryWeaponEnabled( entity player, var rui, string endString )
{
	player.EndSignal( endString )
	player.EndSignal( "OnDeath" )

	while ( IsAlive( player ) )
	{
		bool weaponUsesAmmoStatus 	= false
		entity selectedWeapon	 	= player.GetActiveWeapon( eActiveInventorySlot.mainHand )
		if ( IsValid( selectedWeapon ) )
			weaponUsesAmmoStatus = !player.IsUsingOffhandWeapon( eActiveInventorySlot.mainHand ) || selectedWeapon.GetWeaponSettingBool( eWeaponVar.offhand_uses_hud_ammo_status )

		RuiSetBool( rui, "weaponIsUp", player.GetWeaponDisableFlags() != WEAPON_DISABLE_FLAGS_ALL && player.GetWeaponDisableFlags() != WEAPON_DISABLE_FLAGS_MAIN && weaponUsesAmmoStatus )
		WaitFrame()
	}
}


void function TrackOffhandWeaponSlot( entity player, var rui, int slot )
{
	player.EndSignal( "EndTrackOffhandWeaponSlot" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( rui )
		{
			RuiSetBool( rui, "isVisible", false )
		}
	)

	switch ( slot )
	{
		case OFFHAND_RIGHT:
			UpdateOffhandRuiVisibility( rui, "%offhand0%" )
			break

		case OFFHAND_LEFT:
			UpdateOffhandRuiVisibility( rui, "%offhand1%" )
			break

		case OFFHAND_TITAN_CENTER:
			UpdateOffhandRuiVisibility( rui, "%offhand2%" )
			break

		case OFFHAND_INVENTORY:
			if ( IsControllerModeActive() )
				UpdateOffhandRuiVisibility( rui, "%offhand1%+%ping%" )
			else
				UpdateOffhandRuiVisibility( rui, "%offhand4%" )
			break
	}

	entity lastWeapon               = null
	bool wasVisible                 = file.slotVisible[slot]
	while ( IsAlive( player ) )
	{
		entity weapon = player.GetOffhandWeapon( slot )
		if ( weapon != lastWeapon || file.slotVisible[slot] != wasVisible )
		{
			if ( IsValid( weapon ) && file.slotVisible[slot] )
			{
				thread InitOffhandRui( rui, player, weapon )
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
			}
		}

		switch ( slot )
		{
			case OFFHAND_INVENTORY:
				if ( IsControllerModeActive() )
					UpdateOffhandRuiVisibility( rui, "%offhand1%+%ping%" )
				else
					UpdateOffhandRuiVisibility( rui, "%offhand4%" )
				break
			case OFFHAND_LEFT:
				UpdateOffhandRuiVisibility( rui, "%offhand1%" )
				break
		}

		foreach ( func in file.weaponStatusUpdateCallbacks )
			func( player, rui, slot )

		lastWeapon = weapon
		wasVisible = file.slotVisible[slot]
		WaitFrame()
	}
}


void function UltimateWeaponStatusUpdate( entity player, var rui, int slot )
{
	// ideally this could be changed to a code callback when an offhand weapon gets enough clip ammo to fire.
	// and one callback when the weapon becomes ready to fire. Though that seems to happen at odd moments.
	// It's unfortunate that it's so hard to get the state that an weapon is in. :-(

	#if R5DEV
		if ( file.devTestingUltimateStates )
			return
	#endif //DEV

	if ( slot != OFFHAND_ULTIMATE )
		return

	entity weapon = player.GetOffhandWeapon( OFFHAND_ULTIMATE )
	if ( !IsValid( weapon ) )
		return

	int maxClipCount = weapon.GetWeaponPrimaryClipCountMax()
	int clipCount    = weapon.GetWeaponPrimaryClipCount()

	bool ultimateReady = (clipCount >= maxClipCount)

	if ( ultimateReady && GetUltimateWeaponState() < eUltimateState.READY )
		UltimateWeaponStateSet( eUltimateState.READY )
	else if ( !ultimateReady && GetUltimateWeaponState() > eUltimateState.CHARGING && weapon.IsReadyToFire() )
		UltimateWeaponStateSet( eUltimateState.CHARGING )
	// might have to add an else herer to turn it so active once we don't do this every frame to handle spectating fully
}


int currentUltimateState = eUltimateState.CHARGING
void function UltimateWeaponStateSet( int ultimateWeaponState )
{
	int lastUltimateState = currentUltimateState
	currentUltimateState = ultimateWeaponState

	if ( lastUltimateState == currentUltimateState )
		return

	Signal( clGlobal.levelEnt, "ultimate_weapon_status_changed" )

	switch( currentUltimateState )
	{
		case eUltimateState.CHARGING:
			UltimateWeaponStateCharging()
			break

		case eUltimateState.READY:
			UltimateWeaponStateReady()
			break

		case eUltimateState.ACTIVE:
			UltimateWeaponStateActive()
			break
	}
}


int function GetUltimateWeaponState()
{
	return currentUltimateState
}


void function UltimateWeaponStateCharging()
{
	RuiSetGameTime( file.ability_left_hud, "regenBeginTime", Time() )
}


void function UltimateWeaponStateReady()
{
	// this is being tracked by chargeFrac in the rui. We have a callback for it now, but it doesn't trigger when using infinite ammo etc. so I'm not using it for now.
}


void function UltimateWeaponStateActive()
{
	RuiSetGameTime( file.ability_left_hud, "ultimateActivatedTime", Time() )
}


void function UltimateReadyVideoFinished( int channel )
{
	printt( "UltimateReadyVideoFinished" )
	Signal( clGlobal.levelEnt, "ultimate_video_finished" )
}

#if R5DEV
void function DEV_TestUltimateStates()
{
	thread DEV_TestUltimateStatesThread()
}

void function DEV_TestUltimateStatesThread()
{
	Assert ( IsNewThread(), "Must be threaded off." )

	file.devTestingUltimateStates = true

	UltimateWeaponStateSet( eUltimateState.CHARGING )
	wait 0.5
	UltimateWeaponStateSet( eUltimateState.READY )
	wait 5
	UltimateWeaponStateSet( eUltimateState.ACTIVE )
	wait 5
	UltimateWeaponStateSet( eUltimateState.CHARGING )

	wait 2
	file.devTestingUltimateStates = false
}
#endif //DEV


void function TrackATWeaponSlot( entity player, var rui )
{
	player.EndSignal( "EndTrackOffhandWeaponSlot" )
	player.EndSignal( "OnDeath" )

	OnThreadEnd(
		function() : ( rui )
		{
			RuiSetBool( rui, "isVisible", false )
		}
	)

	entity lastWeapon     = null
	bool wasVisible       = file.slotVisible[OFFHAND_INVENTORY]
	bool wasHoldingWeapon = player.GetActiveWeapon( eActiveInventorySlot.mainHand ) == player.GetAntiTitanWeapon()
	while ( IsAlive( player ) )
	{
		entity weapon        = player.GetAntiTitanWeapon()
		entity activeWeapon  = player.GetActiveWeapon( eActiveInventorySlot.mainHand )
		bool isHoldingWeapon = weapon == activeWeapon
		if ( weapon != lastWeapon || file.slotVisible[OFFHAND_INVENTORY] != wasVisible || isHoldingWeapon != wasHoldingWeapon )
		{
			if ( IsValid( weapon ) && file.slotVisible[OFFHAND_INVENTORY] && !isHoldingWeapon )
			{
				thread InitOffhandRui( rui, player, weapon )
				RuiSetFloat2( rui, "iconSizeScale", <1.5, 0.75, 0> )
			}
			else
			{
				RuiSetBool( rui, "isVisible", false )
			}
		}

		lastWeapon = weapon
		wasVisible = file.slotVisible[OFFHAND_INVENTORY]
		wasHoldingWeapon = isHoldingWeapon
		WaitFrame()
	}
}
/*
	// VECTOR TYPES
	RUI_TRACK_ABSORIGIN_FOLLOW,						// Create at absorigin, and update to follow the entity
	RUI_TRACK_POINT_FOLLOW,							// Create on attachment point, and update to follow the entity
	RUI_TRACK_OVERHEAD_FOLLOW,						// Create at the top of the entity's bbox
	RUI_TRACK_EYEANGLES_FOLLOW,
	RUI_TRACK_WAYPOINT_VECTOR,

	// FLOAT TYPES
	RUI_TRACK_HEALTH,								// Health as fraction from 0 to 1
	RUI_TRACK_FRIENDLINESS,							// 0 if ent is enemy, 1 if it's friendly
	RUI_TRACK_PLAYER_SUIT_POWER,					// Player's suit power from 0 to 1
	RUI_TRACK_PLAYER_GRAPPLE_POWER,					// Player's grapple power from 0 to 1
	RUI_TRACK_PLAYER_SHARED_ENERGY,					// Players shared energy value
	RUI_TRACK_WEAPON_CHARGE_FRACTION,				// Weapon charge as fraction from 0 to 1
	RUI_TRACK_WEAPON_SMART_AMMO_LOCK_FRACTION,		// Smart ammo weapon lock fraction from 0 to N
	RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION,		// Weapon cooldown as fraction from 0 to 1
	RUI_TRACK_WEAPON_RELOAD_FRACTION,				// Weapon reloading as fraction from 0 to 1
	RUI_TRACK_WEAPON_DRYFIRE_FRACTION,				//
	RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION,			// Weapon clip ammo as fraction from 0 to 1
	RUI_TRACK_WEAPON_REMAINING_AMMO_FRACTION,		// Weapon remaining ammo as fraction from 0 to 1
	RUI_TRACK_WEAPON_CLIP_AMMO_MAX,					//
	RUI_TRACK_WEAPON_AMMO_MAX,						//
	RUI_TRACK_WEAPON_LIFETIME_SHOTS,				//
	RUI_TRACK_WEAPON_AMMO_REGEN_RATE,				//
	RUI_TRACK_WEAPON_STOCKPILE_REGEN_FRAC,			// fraction of a players stockpile regen
	RUI_TRACK_BOOST_METER_FRACTION,					// Player boost meter as fraction from 0 to 1
	RUI_TRACK_GLIDE_METER_FRACTION,					// Player glide meter as fraction from 0 to 1
	RUI_TRACK_SHIELD_FRACTION,						// Shield health as fraction from 0 to 1
	RUI_TRACK_STATUS_EFFECT_SEVERITY,				// Status effect severity as fraction from 0 to 1; attachmentIndex used as status effect index
	RUI_TRACK_SCRIPT_NETWORK_VAR,					// Value of a script network variable (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL,			// Value of a script network variable without an entity (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_LOCAL_VIEW_PLAYER,	// Value of a script network variable on the local view player (changes automatically during kill replay) (use GetNetworkedVariableIndex())
	RUI_TRACK_FRIENDLY_TEAM_SCORE,					//
	RUI_TRACK_FRIENDLY_TEAM_ROUND_SCORE,			// The value of score2 for friendlies
	RUI_TRACK_ENEMY_TEAM_SCORE,						//
	RUI_TRACK_ENEMY_TEAM_ROUND_SCORE,				// The value of score2 for enemies
	RUI_TRACK_MINIMAP_SCALE,						//
	RUI_TRACK_SOUND_METER,							// Sound meter as fraction from 0 to 1.
	RUI_TRACK_GAME_FULLY_INSTALLED_PROGRESS,		// Fraction of full game downloaded 0 to 1
	RUI_TRACK_WAYPOINT_FLOAT,

	// INT TYPES
	RUI_TRACK_MINIMAP_FLAGS,
	RUI_TRACK_MINIMAP_CUSTOM_STATE,
	RUI_TRACK_TEAM_RELATION_VIEWPLAYER,					// ENEMY: -1, NEUTRAL: 0, FRIENDLY: 1
	RUI_TRACK_TEAM_RELATION_CLIENTPLAYER,				// ENEMY: -1, NEUTRAL: 0, FRIENDLY: 1
	RUI_TRACK_SCRIPT_NETWORK_VAR_INT,					// Value of a script network variable (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_GLOBAL_INT,			// Value of a script network variable without an entity (use GetNetworkedVariableIndex())
	RUI_TRACK_SCRIPT_NETWORK_VAR_LOCAL_VIEW_PLAYER_INT,	// Value of a script network variable on the local view player (changes automatically during kill replay) (use GetNetworkedVariableIndex())
	RUI_TRACK_WAYPOINT_INT,
	RUI_TRACK_WAYPOINT_BITFIELD,
	RUI_TRACK_PLAYER_AMMO_POOL,							// Player's ammo pool count

	// GAMETIME TYPES
	RUI_TRACK_LAST_FIRED_TIME,
	RUI_TRACK_MINIMAP_THREAT_SECTOR,
	RUI_TRACK_WAYPOINT_GAMETIME,

	// IMAGE TYPES
	RUI_TRACK_WEAPON_MENU_ICON,
	RUI_TRACK_WEAPON_HUD_ICON,
	RUI_TRACK_WAYPOINT_IMAGE,

	// STRING TYPES
	RUI_TRACK_WAYPOINT_STRING,
	RUI_TRACK_PLAYER_NAME_STRING
*/

void function InitOffhandRui( var rui, entity player, entity weapon )
{
	Assert ( IsNewThread(), "Must be threaded off." )

	EndSignal( player, "OnDestroy" ) //LoadoutSlot_WaitForItemFlavor could take time so player and weapon might get destroyed
	EndSignal( weapon, "OnDestroy" )

	RuiSetGameTime( rui, "hintTime", Time() )

	RuiSetBool( rui, "isTitan", player.IsTitan() )
	RuiSetBool( rui, "isVisible", (GetHudDefaultVisibility() && !player.IsTitan()) )
	RuiSetBool( rui, "isReverseCharge", false )
	bool isPaused = weapon.HasMod( "survival_ammo_regen_paused" )
	RuiSetBool( rui, "isPaused", isPaused )

	RuiSetFloat( rui, "chargeFrac", 0.0 )
	RuiSetFloat( rui, "useFrac", 0.0 )
	RuiSetFloat( rui, "chargeMaxFrac", 1.0 )
	RuiSetFloat( rui, "minFireFrac", 1.0 )
	RuiSetInt( rui, "segments", 1 )
	RuiTrackFloat( rui, "refillRate", weapon, RUI_TRACK_WEAPON_AMMO_REGEN_RATE )

	RuiTrackImage( rui, "hudIcon", weapon, RUI_TRACK_WEAPON_HUD_ICON )

	RuiTrackFloat( rui, "readyFrac", weapon, RUI_TRACK_WEAPON_READY_TO_FIRE_FRACTION )
	RuiTrackFloat( rui, "dryfireFrac", weapon, RUI_TRACK_WEAPON_DRYFIRE_FRACTION )

	RuiSetFloat( rui, "chargeFracCaution", 0.0 )
	RuiSetFloat( rui, "chargeFracAlert", 0.0 )
	RuiSetFloat( rui, "chargeFracAlertSpeed", 16.0 )
	RuiSetFloat( rui, "chargeFracAlertScale", 1.0 )

	RuiSetInt( rui, "ammoMinToFire", weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire ) )

	ItemFlavor character                    = LoadoutSlot_WaitForItemFlavor( ToEHI( player ), Loadout_CharacterClass() )
	CharacterHudUltimateColorData colorData = CharacterClass_GetHudUltimateColorData( character )

	RuiSetColorAlpha( rui, "ultimateColor", SrgbToLinear( colorData.ultimateColor ), 1 )
	RuiSetColorAlpha( rui, "ultimateColorHighlight", SrgbToLinear( colorData.ultimateColorHighlight ), 1 )

	switch ( weapon.GetWeaponSettingEnum( eWeaponVar.cooldown_type, eWeaponCooldownType ) )
	{
		case eWeaponCooldownType.ammo_timed:
		case eWeaponCooldownType.ammo_instant:
		case eWeaponCooldownType.ammo_deployed:
			RuiSetFloat( rui, "readyFrac", 0.0 )

		case eWeaponCooldownType.ammo:
			int maxAmmoReady = weapon.UsesClipsForAmmo() ? weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size ) : weapon.GetWeaponPrimaryAmmoCountMax( weapon.GetActiveAmmoSource() )
			int ammoPerShot = weapon.GetWeaponSettingInt( eWeaponVar.ammo_per_shot )
			int ammoMinToFire = weapon.GetWeaponSettingInt( eWeaponVar.ammo_min_to_fire )

			if ( maxAmmoReady == 0 )
				maxAmmoReady = 1
			RuiSetFloat( rui, "minFireFrac", float( ammoMinToFire ) / float( maxAmmoReady ) )
			if ( ammoPerShot == 0 )
				ammoPerShot = 1
			RuiSetInt( rui, "segments", maxAmmoReady / ammoPerShot )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CLIP_AMMO_FRACTION )

			RuiTrackFloat( rui, "useFrac", weapon, RUI_TRACK_STATUS_EFFECT_SEVERITY, eStatusEffect.simple_timer )

			//RuiSetFloat( rui, "refillRate", weapon.GetWeaponSettingFloat( eWeaponVar.regen_ammo_refill_rate ) ) // todo(dw): updated live by TrackOffhandWeaponSlot for now
			break

		case eWeaponCooldownType.vortex_drain:
			RuiSetBool( rui, "isReverseCharge", true )
			RuiSetFloat( rui, "chargeFrac", 1.0 )
			RuiSetFloat( rui, "readyFrac", 0.0 )
			RuiSetFloat( rui, "minFireFrac", 0.0 )

			RuiTrackFloat( rui, "chargeFrac", weapon, RUI_TRACK_WEAPON_CHARGE_FRACTION )
			break

		default:
			Assert( false, "Unsupported cooldown_type: " + weapon.GetWeaponSettingEnum( eWeaponVar.cooldown_type, eWeaponCooldownType ) )
	}
}

void function ClWeaponStatus_UpdateShowButtonHint()
{
	if ( file.weapon_hud_rui != null )
		RuiSetBool( file.weapon_hud_rui, "showButtonHints", ShouldShowButtonHints() )
}


var function GetRuiForIndex( entity player, int offhandIndex )
{
	var rui

	if ( player.IsTitan() )
	{
		switch ( offhandIndex )
		{
			case OFFHAND_LEFT:
				rui = file.ability_left_hud
				break

			case OFFHAND_TITAN_CENTER:
				rui = file.ability_center_hud
				break

			case OFFHAND_RIGHT:
				rui = file.ability_right_hud
				break
		}
	}
	else
	{
		switch ( offhandIndex )
		{
			case OFFHAND_LEFT:
				rui = file.ability_left_hud
				break

			case OFFHAND_RIGHT:
				rui = file.ability_center_hud
				break
		}
	}

	return rui
}


bool function GetHudDefaultVisibility()
{
	return true
}


bool function IsWeaponInPrimarySlot2( entity player, entity weapon )
{
	if ( !IsValid( weapon ) )
		return false

	return weapon == player.GetNormalWeapon( WEAPON_INVENTORY_SLOT_PRIMARY_2 )
}
