untyped


global function ZiplinePrecache
global function Zipline_Register
global function Zipline_CreatePanel
global function RegisteredZipline_Init
global function Zipline_InitAllRegisteredZiplineInScope

global function GetZiplineArray
global function ChooseZiplineSkinByTraceResults
global function IsZiplineHaveSameName
global function IsZiplineVertical
global function IsZiplineDestroyed
global function IsCanyonlandsMap
global function ChooseZiplineTravelTime
global function GZFEP
global function GZFZN
global function Zipline_CreateProp
global function ZiplineErrorOnClientConnected
global function ZiplineAddErrorReason


////////////////////////////////////////////////////////////
//  Initialize zipline
////////////////////////////////////////////////////////////
ZiplineUtility function Zipline_Register( string ziplineName, vector startEntityPos, vector startEntityAng, vector ornull endEntityPos = null, vector endEntityAng = < 0, 0, 0 > )
{
    ZiplineUtility zipline ; KVFilesSettings settings = zipline.settings ; ZiplineVars vars = zipline.vars ; ZiplineState state = zipline.state

    // Name
    if ( IsZiplineHaveSameName( ziplineName ) ) ziplineName = UniqueZiplineString( ziplineName ) ; vars.ziplineName = ziplineName

    // Start Origin
    zipline.startEntityPos = startEntityPos ; zipline.startEntityAng  = startEntityAng

    // End Origin
    if ( endEntityPos ) zipline.endEntityPos = expect vector( endEntityPos ) ; zipline.endEntityAng = endEntityAng

    // Determine if is vertical
    settings.isVertical = endEntityPos == null ? true : false

    ZiplinePreProcess( zipline ) ; Zipline_SetZiplineAngles( zipline, startEntityAng, endEntityAng )

    #if PANEL_DEBUG_NO_TIMER
        Zipline_SetPanelTimer( zipline, 0.0 )
    #endif // PANEL_DEBUG_NO_TIMER

    ziplineUtility.zipline[ziplineName] <- zipline ; ziplineUtility.ziplineArray.append( zipline )

return ziplineUtility.zipline[ziplineName] }


////////////////////////////////////////////////////////////
//  Create panel for ziplines
////////////////////////////////////////////////////////////
void function Zipline_CreatePanel( ZiplineUtility zipline, vector pos, vector ang, int skin = ePanelSkinType.WALL )
{
    ZiplineState state = zipline.state ; ZiplinePanel panels = zipline.panels

    #if ZIPLINE_DEBUG_SCRIPTS
        if ( IsCanyonlandsMap() && skin == ePanelSkinType.WALL )
            ZiplineAddErrorMinorReason( zipline, WALL_PANEL_MODEL_DOES_NOT_EXIST )
    #endif // ZIPLINE_DEBUG_SCRIPTS

    entity panel = CreateUsablePanel( DecidePanelModel( skin ), pos, ang )
    panel.SetSkin( ePanelState.ENABLE )

    if ( state.firstInit ) thread UpdatePanelForFirstTimeInited( zipline )
    panels.newPanel.append( panel )
}


////////////////////////////////////////////////////////////
//  Create zipline
////////////////////////////////////////////////////////////
void function RegisteredZipline_Init( ZiplineUtility zipline )
{
    ZiplineVars vars = zipline.vars ; ZiplineState state = zipline.state

    if ( !state.supportIsValid ) Zipline_InitSupport( zipline )
    if ( !state.ziplineIsValid && !vars.spawnSupportOnly ) Zipline_InitZipline( zipline )
    UpdatePanelsPrompts( zipline )

    vars.spawnSupportOnly   = false
    state.firstInit         = false
}


void function Zipline_InitAllRegisteredZiplineInScope()
{
    foreach ( ziplines in GetZiplineArray() )
    {
        ZiplineState state = ziplines.state
        if ( state.firstInit ) RegisteredZipline_Init( ziplines )
    }
}


////////////////////////////////////////////////////////////
//  Function used after RegisteredZipline_Init()
///////////////////////////////////////////////////////////
array< entity > function Zipline_InitSupport( ZiplineUtility zipline )
{
    KVFilesSettings settings = zipline.settings ; ZiplineVars vars = zipline.vars ; ZiplineState state = zipline.state

    // Entities Declaration
    array< entity > entityArray = [ ] ; entity startSupport ; entity startArm ; entity midSupport ; entity midArm ; entity endSupport ; entity endArm

    // Vector Declaration
    array< vector > moveRopePath = zipline.moveRopeZiplinePos

    // Offset for arm heigth | locked between 160.0 (min) / 280.0 (max)
    float minOffset = ARM_MIN_OFFSET ; float maxOffset = ARM_MAX_OFFSET
    float startArmOffset = vars.startArmOffset ; float endArmOffset = vars.endArmOffset
    if ( startArmOffset < minOffset ) startArmOffset = minOffset else if ( startArmOffset > maxOffset ) startArmOffset = maxOffset
    if ( endArmOffset   < minOffset ) endArmOffset   = minOffset else if ( endArmOffset   > maxOffset ) endArmOffset   = maxOffset

    // Temporary angle for the right position | Position offsets calculation
    vector startEntityPos = zipline.startEntityPos ; vector startEntityAng = zipline.startEntityAng ; vector endEntityPos = zipline.endEntityPos ; vector endEntityAng = zipline.endEntityAng
    vector startEntityPosArm = startEntityPos + < -1, -2, startArmOffset > ; vector endEntityPosArm = endEntityPos + < -1, -2, endArmOffset >
    vector angOffset = < 0, 90, 0 > ; vector tempAng = < 0, 0, 0 > ; vector tempAngForSupport = < 0, 90, 0 >
    vector startArmAng = startEntityAng - angOffset ; vector endArmAng = endEntityAng - angOffset

    if ( vars.isLinkedZiplineStart ) vars.setSkinStart = eZiplineSkinType.INVISIBLE ; if ( vars.isLinkedZiplineEnd ) vars.setSkinEnd = eZiplineSkinType.INVISIBLE

    switch ( vars.setSkinStart ) // With / Without support selection
    {
        case eZiplineSkinType.ENTIRE: // With support
            startSupport    = Zipline_CreateProp( ZIPLINE_SUPPORT, startEntityPos, tempAngForSupport )
            startArm        = Zipline_CreateProp( ZIPLINE_ARM, startEntityPosArm, tempAng )
            startArm.SetParent( startSupport ) ; startSupport.SetAngles( startEntityAng )
            entityArray.append( startSupport ) // Add to array for return
            break
        case eZiplineSkinType.ARM_ONLY: // Without support
            startArm        = Zipline_CreateProp( ZIPLINE_ARM, startEntityPos, startArmAng )
            break
        case eZiplineSkinType.INVISIBLE: // Invisible model
            startArm        = Zipline_CreateProp( EMPTY_MODEL, startEntityPos, startArmAng )
        default: break

    }

    entityArray.append( startArm ) // Add to array for return

    // Return origin point of the zipline
    if ( vars.setSkinStart != eZiplineSkinType.INVISIBLE ) zipline.startZiplinePos = PositionOffsetFromEnt( startArm, -4, -55.5, -12 ) else zipline.startZiplinePos = startEntityPos
    moveRopePath.append( zipline.startZiplinePos )

    for ( int i = 0 ; i < zipline.moveRopePathPos.len() ; i++ )
    {
        vector  midEntityPos    = zipline.moveRopePathPos[ i ]
        vector  midEntityAng    = zipline.moveRopePathAng[ i ]
        int     pathSkin        = zipline.moveRopePathSkin[ i ]

        vector  midEntityPosArm = midEntityPos + < -1, -2, 200 >
        vector  midArmAng       = midEntityAng - angOffset

        switch ( pathSkin ) // With / Without support selection
        {
            case eZiplineSkinType.ENTIRE: // With support
                midSupport    = Zipline_CreateProp( ZIPLINE_SUPPORT, midEntityPos, tempAngForSupport )
                midArm        = Zipline_CreateProp( ZIPLINE_ARM, midEntityPosArm, tempAng, true )
                midArm.SetParent( midSupport ) ; midSupport.SetAngles( midEntityAng )
                moveRopePath.append( PositionOffsetFromEnt( midArm, -4, -55.5, -12 ) )
                break
            case eZiplineSkinType.ARM_ONLY: // Without support
                midArm        = Zipline_CreateProp( ZIPLINE_ARM, midEntityPos, midArmAng, true )
                moveRopePath.append( PositionOffsetFromEnt( midArm, -4, -55.5, -12 ) )
                break
            case eZiplineSkinType.INVISIBLE: // Invisible model
                midArm        = Zipline_CreateProp( EMPTY_MODEL, midEntityPos, midArmAng )
                moveRopePath.append( midEntityPos )
            default: break
        }

        //vector appendOrigin = PositionOffsetFromEnt( midArm, -4, -55.5, -12 )
        //if ( pathSkin != eZiplineSkinType.INVISIBLE && IsValid( endArm ) ) zipline.moveRopeZiplinePos.append( appendOrigin ) else zipline.moveRopeZiplinePos.append( midEntityPos )
    }

    if ( !IsZiplineVertical( zipline ) ) // If vertical
    {
        switch ( vars.setSkinEnd ) // With / Without support selection
        {
            case eZiplineSkinType.ENTIRE: // With support
                endSupport    = Zipline_CreateProp( ZIPLINE_SUPPORT, endEntityPos, tempAngForSupport )
                endArm        = Zipline_CreateProp( ZIPLINE_ARM, endEntityPosArm, tempAng )
                endArm.SetParent( endSupport ) ; endSupport.SetAngles( endEntityAng )
                entityArray.append( endSupport )  // Add to array for return
                break
            case eZiplineSkinType.ARM_ONLY: // Without support
                endArm        = Zipline_CreateProp( ZIPLINE_ARM, endEntityPos, endArmAng )
                break
            case eZiplineSkinType.INVISIBLE: // Invisible model
                endArm        = Zipline_CreateProp( EMPTY_MODEL, endEntityPos, endArmAng )
                break
            default: break
        }

        entityArray.append( endArm ) // Add to array for return
    }

    ArrayRemoveInvalid( entityArray ) // Remove invalid ents

    // Return origin point of the zipline
    if ( vars.setSkinEnd != eZiplineSkinType.INVISIBLE && IsValid( endArm ) ) zipline.endZiplinePos = PositionOffsetFromEnt( endArm, -4, -55.5, -12 ) else zipline.endZiplinePos = endEntityPos
    moveRopePath.append( zipline.endZiplinePos )

    // Set script name and target
    foreach ( ents in entityArray )
    {
        
        if ( !IsZiplineVertical( zipline ) ) ents.SetScriptName( HORIZONTAL_ZIPLINE_SCRIPT_NAME )
        else
        {
            ents.SetScriptName( VERTICAL_ZIPLINE_SCRIPT_NAME )
            SetTargetName( ents, vars.ziplineName )
        }

    }

    if ( !IsZiplineVertical( zipline ) )
    {
        if ( IsValid( startSupport ) ) SetTargetName( startSupport, vars.ziplineName + "_start" ) ; SetTargetName( startArm, vars.ziplineName + "_start" )
        if ( IsValid( endSupport ) )   SetTargetName( endSupport,   vars.ziplineName + "_end" )   ; SetTargetName( endArm,   vars.ziplineName + "_end" )
    }


    state.supportIsValid = true ; zipline.supportArray.extend( entityArray )

return entityArray }


array< entity > function Zipline_InitZipline( ZiplineUtility zipline )
{
    KVFilesSettings settings = zipline.settings ; ZiplineVars vars = zipline.vars ; ZiplinePanel panels = zipline.panels ; ZiplineState state = zipline.state

    // Calculation part
    vector startZiplinePos = zipline.startZiplinePos ; vector endZiplinePos ; vector startZiplineAng ; vector endZiplineAng ; array < entity > returnedEntity
    
    switch ( settings.isVertical )
    {
        case true:
            vector offset         = startZiplinePos - TRACE_RESULTS_OFFSET
            TraceResults result   = TraceLine( offset, offset + -vars.heightLimitFromTop * < 0, 0, 1 >, [], TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_PLAYER )
            startZiplineAng       = zipline.startZiplineAng ; endZiplineAng = zipline.endZiplineAng

            if ( !vars.disableVerticalZiplineOffset )
            {
                if ( vars.boolHeightLimitFromTop ) endZiplinePos = result.endPos
                else if ( vars.boolHeightLimitFromFloor || vars.boolHeightLimitByIndianaJonesMode ) endZiplinePos = result.endPos + < 0, 0, vars.heightLimitFromFloor >
                else { endZiplinePos = result.endPos + ZIPLINE_OFFSET_FROM_FLOOR }
            }
            else
            {
                endZiplinePos = result.endPos
            }

            if ( vars.heightLimitInt >= 2 ) ZiplineAddErrorReason( zipline, REASON_TOO_MANY_HEIGHT_LIMIT )

            zipline.endZiplinePos = endZiplinePos
            break
        case false:
            startZiplineAng    = zipline.startZiplineAng ; endZiplineAng = zipline.endZiplineAng ; endZiplinePos = zipline.endZiplinePos

            startZiplineAng    = VectorToAngles( Normalize( endZiplinePos - startZiplinePos ) )
            startZiplineAng.x  = startZiplineAng.x % 180.0
            startZiplineAng.y  = startZiplineAng.y % 180.0
            startZiplineAng.z  = startZiplineAng.z % 180.0

            endZiplineAng      = VectorToAngles( Normalize( startZiplinePos - endZiplinePos ) )
            endZiplineAng.x    = endZiplineAng.x % 180.0
            endZiplineAng.y    = endZiplineAng.y % 180.0
            endZiplineAng.z    = endZiplineAng.z % 180.0
            break
        default: break
    }

    if ( vars.isLinkedZiplineEnd || vars.isLinkedZiplineHost || vars.isMoveRope )
    {
        if ( panels.newPanel.len() != 0 )
            ZiplineAddErrorMinorReason( zipline, REASON_PANEL_WRONG_CONFIGURATION )
        DestoryAllPanelsInZiplineStruct( zipline )
    }

    if ( vars.isMoving )
        endZiplinePos = startZiplinePos - < 0, 0, 0.1 >

    if ( startZiplinePos == endZiplinePos )
        ZiplineAddErrorReason( zipline, REASON_ROPE_HAVE_SAME_ORIGIN )

    // If an error is detected do not create the zip
    if ( state.error ) return []

    if ( !vars.isMoveRope )
    {
        // Create start point
        entity startEntityZiplinePoint = CreateEntity( "zipline" )

        startEntityZiplinePoint.kv.DetachEndOnSpawn             = settings.detachEndOnSpawn
        startEntityZiplinePoint.kv.DetachEndOnUse               = settings.detachEndOnUse
        startEntityZiplinePoint.kv.Material                     = settings.material
        startEntityZiplinePoint.kv.scale                        = settings.scale
        startEntityZiplinePoint.kv.Width                        = settings.width
        startEntityZiplinePoint.kv.ZiplineAutoDetachDistance    = settings.startAutoDetachDistance
        startEntityZiplinePoint.kv.ZiplineDropToBottom          = settings.dropToBottom
        startEntityZiplinePoint.kv.ZiplineFadeDistance          = settings.fadeDistance
        startEntityZiplinePoint.kv.ZiplineLengthScale           = settings.lengthScale
        startEntityZiplinePoint.kv.ZiplinePreserveVelocity      = settings.preserveVelocity
        startEntityZiplinePoint.kv.ZiplinePushOffInDirectionX   = settings.startPushOffInDirectionX
        startEntityZiplinePoint.kv.ZiplineSpeedScale            = settings.speedScale
        startEntityZiplinePoint.kv.ZiplineVersion               = settings.ziplineVersion
        startEntityZiplinePoint.kv.ZiplineVertical              = settings.isVertical

        if ( vars.restPoint && !vars.isMoving )
        {
            startEntityZiplinePoint.kv._zipline_rest_point_0    = startZiplinePos.x + " " + startZiplinePos.y  + " " + startZiplinePos.z
            startEntityZiplinePoint.kv._zipline_rest_point_1    = endZiplinePos.x   + " " + endZiplinePos.y    + " " + endZiplinePos.z
        }

        startEntityZiplinePoint.SetAngles( startZiplineAng )
        startEntityZiplinePoint.SetOrigin( startZiplinePos )

        // Create end point
        entity endEntityZiplinePoint

        if ( vars.isLinkedZiplineEnd )
        {
            switch ( vars.linkedZiplineEndType )
            {
                case eZiplineEndPointType.START:
                    endEntityZiplinePoint = GZFZN( vars.linkedZiplineEndName ).startEntityZiplinePoint
                break

                case eZiplineEndPointType.END:
                    endEntityZiplinePoint = GZFZN( vars.linkedZiplineEndName ).endEntityZiplinePoint
                break
            }
        }
        else
        {
            endEntityZiplinePoint = CreateEntity( "zipline_end" )

            endEntityZiplinePoint.kv.ZiplineAutoDetachDistance    = settings.endAutoDetachDistance
            endEntityZiplinePoint.kv.ZiplinePushOffInDirectionX   = settings.endPushOffInDirectionX

            endEntityZiplinePoint.SetAngles( endZiplineAng )
            endEntityZiplinePoint.SetOrigin( endZiplinePos )

            DispatchSpawn( endEntityZiplinePoint )
        }
    
        startEntityZiplinePoint.LinkToEnt( endEntityZiplinePoint )

        DispatchSpawn( startEntityZiplinePoint )

        zipline.startEntityZiplinePoint = startEntityZiplinePoint
        zipline.endEntityZiplinePoint   = endEntityZiplinePoint

        EmitSoundOnEntity( startEntityZiplinePoint, ZIPLINE_START_SOUND ) ; EmitSoundOnEntity( endEntityZiplinePoint, ZIPLINE_START_SOUND )

        if ( vars.isMoving )
            thread Zipline_Mover( zipline )

        returnedEntity.extend( [ startEntityZiplinePoint, endEntityZiplinePoint ] )

        state.ziplineIsValid     = true
        state.ziplineIsDestroyed = false
    }
    else
    {
        array < entity > ziplinesEntNodes
        array < string > ziplinesEntNames
        array < vector > moveRopeZiplinePos = zipline.moveRopeZiplinePos

        int pointNum = 0
    
        foreach( vector origin in moveRopeZiplinePos )
        {
            string name = UniqueString( "rope_point_" + pointNum )
            ziplinesEntNames.append( name ) ; pointNum++
        }

        int i = 0

        foreach( vector origin in moveRopeZiplinePos )
        {
            if ( i == 0 )
            {
                entity ziplineEnt = CreateZiplinePath( zipline, origin, "move_rope", ziplinesEntNames[i], ziplinesEntNames[i + 1], false )
                ziplinesEntNodes.append( ziplineEnt )
            }
            if ( i != 0 && i < moveRopeZiplinePos.len() - 1 )
            {
                entity ziplineEnt = CreateZiplinePath( zipline, origin, "keyframe_rope", ziplinesEntNames[i], ziplinesEntNames[i + 1], false )
                ziplinesEntNodes.append( ziplineEnt )
            }
            else
            {
                entity ziplineEnt = CreateZiplinePath( zipline, origin, "keyframe_rope", ziplinesEntNames[i], "", true )
                ziplinesEntNodes.append( ziplineEnt )
            }

            i++

        }

        foreach( entity ent in ziplinesEntNodes )
        {
            DispatchSpawn( ent )
        }

    }

return returnedEntity }


////////////////////////////////////////////////////////////
//  Utility
////////////////////////////////////////////////////////////
void function ZiplinePrecache()
{
    PrecacheModel( ZIPLINE_ARM )
    PrecacheModel( ZIPLINE_PLANEL_STAND )
    PrecacheModel( ZIPLINE_SUPPORT )

    if ( !IsCanyonlandsMap() ) PrecacheModel( ZIPLINE_PLANEL_WALL )

    PrecacheParticleSystem( ZIPLINE_EXPLOSION )

    #if ZIPLINE_DEBUG_SCRIPTS
        PrecacheParticleSystem( ZIPLINE_ERROR_FX )
    #endif // ZIPLINE_DEBUG_SCRIPTS
}


function ZiplinePreProcess( ZiplineUtility zipline )
{
    KVFilesSettings settings = zipline.settings ; ZiplineVars vars = zipline.vars
    switch ( settings.isVertical )
    {
        case true:
            settings.endAutoDetachDistance    = END_AUTO_DETACH_DISTANCE
            settings.startAutoDetachDistance  = START_AUTO_DETACH_DISTANCE
            vars.endArmOffset                 = VERTICAL_ARM_OFFSET
            vars.startArmOffset               = VERTICAL_ARM_OFFSET
            break
        case false:
            settings.endAutoDetachDistance    = HORIZONTAL_AUTO_DETACH_DISTANCE
            settings.startAutoDetachDistance  = HORIZONTAL_AUTO_DETACH_DISTANCE
            vars.endArmOffset                 = HORIZONTAL_ARM_OFFSET
            vars.startArmOffset               = HORIZONTAL_ARM_OFFSET

            if ( zipline.startEntityPos.z == zipline.endEntityPos.z ) settings.lengthScale = ZIPLINE_LENGTH_OFFSET_SAME_Z_POS
            break
        default: break
    }
}


function Zipline_Mover( ZiplineUtility zipline )
{
    KVFilesSettings settings = zipline.settings ; ZiplineVars vars = zipline.vars ; ZiplinePanel panels = zipline.panels ; ZiplineState state = zipline.state

    entity startPoint = zipline.startEntityZiplinePoint
    entity endPoint   = zipline.endEntityZiplinePoint
    array< entity > panelArray = panels.newPanel

    startPoint.Zipline_Disable()

    entity mover = CreateOwnedScriptMover( endPoint )
    endPoint.SetParent( mover )

    OnThreadEnd( function() : ( startPoint, endPoint, mover )
    {
        if ( IsValid( endPoint ) ) endPoint.ClearParent()
        if ( IsValid( endPoint ) ) { if ( IsValid( mover ) && endPoint.GetParent() == null ) mover.Destroy() }
        if ( IsValid( startPoint) ) startPoint.Zipline_Enable()
    })

    float travelTime = ChooseZiplineTravelTime( zipline ) ; float travelTimeDivised

    if ( state.firstInit ) travelTime = 1.0

    travelTimeDivised = travelTime / 2

    mover.MoveTo( zipline.endZiplinePos, travelTime, travelTimeDivised, travelTimeDivised )

    wait travelTime
}


array< ZiplineUtility > function GetZiplineArray()
{
    return ziplineUtility.ziplineArray
}


float function ChooseZiplineTravelTime( ZiplineUtility zipline )
{
    float travelTime
    if ( IsZiplineVertical( zipline ) ) { travelTime = 6.0 } else { travelTime = 2.0 }

    #if ZIPLINE_DEBUG_SCRIPTS
        travelTime = 1.0
    #endif // ZIPLINE_DEBUG_SCRIPTS

    return travelTime
}


int function ChooseZiplineSkinByTraceResults( vector vec )
{
    int skin

    if( vec.x || vec.y != 0.0 )
        skin = eZiplineSkinType.ARM_ONLY
    
    else if ( vec.z >= 0.0 )
        skin = eZiplineSkinType.ENTIRE
    
    else if ( vec.z <= 0.0 )
        skin = eZiplineSkinType.INVISIBLE

    return skin
}


bool function IsZiplineHaveSameName( string ziplineName )
{
    foreach ( ziplines in GetZiplineArray() )
    {
        if ( ziplines.vars.ziplineName == ziplineName )
            return true
    }
return false }


bool function IsZiplineVertical( ZiplineUtility zipline )
{
    if ( zipline.settings.isVertical )
        return true

return false }


bool function IsZiplineDestroyed( ZiplineUtility zipline )
{
    if ( zipline.state.ziplineIsDestroyed )
        return true

return false }


bool function IsCanyonlandsMap() // Used as mp_rr_canyonlands does not have ZIPLINE_PLANEL_WALL model
{
    bool isCanyonlandsMap

    switch ( GetMapName() )
    {
        case "mp_rr_canyonlands_staging":
        case "mp_rr_canyonlands_64k_x_64k":
        case "mp_rr_canyonlands_mu1":
        case "mp_rr_canyonlands_mu1_night":
            isCanyonlandsMap = true
        break
        
        default: 
            isCanyonlandsMap = false
        break
    }
    return isCanyonlandsMap
}


int uniqueZiplineId = 0
string function UniqueZiplineString( string str = "" )
{
	return str + "_" + uniqueZiplineId++
}


ZiplineUtility function GZFEP( entity panel )
{
    ZiplineUtility zipline = GetZiplineFromEntityPanel( panel )
    return zipline
}


ZiplineUtility function GZFZN( string ziplineName )
{
    ZiplineUtility zipline = GetZiplineFromZiplineName( ziplineName )
    return zipline
}


ZiplineUtility function GetZiplineFromEntityPanel( entity panel )
{
    ZiplineUtility zipline

    foreach ( ziplines in GetZiplineArray() )
    {
        if ( ziplines.panels.newPanel.contains( panel ) )
            zipline = ziplines
    }

return zipline }


ZiplineUtility function GetZiplineFromZiplineName( string ziplineName )
{
    ZiplineUtility zipline

    foreach ( ziplines in GetZiplineArray() )
    {
        if ( ziplines.vars.ziplineName == ziplineName )
            zipline = ziplines
    }

return zipline }


void function ZiplineErrorOnClientConnected( entity player )
{    
    #if DEVELOPER
        if ( player != gp()[0] )
            return

        thread ZiplineError( player )
    #endif // DEVELOPER
}


void function ZiplineAddErrorReason( ZiplineUtility zipline, string reason )
{
    ZiplineState state = zipline.state
    state.error = true
    state.errorReason.append( reason )
}


void function ZiplineAddErrorMinorReason( ZiplineUtility zipline, string reason )
{
    ZiplineState state = zipline.state
    state.errorMinor = true
    state.errorMinorReason.append( reason )
}


void function ZiplineError( entity player )
{
    array< ZiplineUtility > erronedZipline        = []
    bool errorDetected                            = false
    int count                                     = 0
    int countMinor                                = 0
    int reasonMinorNum                            = 1
    int reasonNum                                 = 1

        wait 1.0 // wait ClientConnected

    foreach( ziplines in GetZiplineArray() )
    {
        if ( ziplines.state.error )
        {
            erronedZipline.append( ziplines ) ; count += 1
            entity fx = StartParticleEffectInWorld_ReturnEntity( GetParticleSystemIndex( ZIPLINE_ERROR_FX ), ziplines.startEntityPos, < 90, 0, 0 > )
        }

        if ( ziplines.state.errorMinor )
        {
            if ( !erronedZipline.contains( ziplines ) ) erronedZipline.append( ziplines ) ; countMinor += 1
        }
    }

    if ( count != 0 || countMinor != 0 ) errorDetected = true

    if ( errorDetected )
    {
        if ( count != 0 )
        {
            if ( count == 1 ) Dev_PrintMessage( player, count + " " + DEV_PRINTMESSAGE_TEXT_SINGULAR, DEV_PRINTMESSAGE_SUBTEXT )
            else Dev_PrintMessage( player, count + " " + DEV_PRINTMESSAGE_TEXT_PLURAL, DEV_PRINTMESSAGE_SUBTEXT )
        }

        printt( "//----------------------------------" )
        foreach( ziplines in erronedZipline )
        {
            printt( "// Error detected on: "  + ziplines.vars.ziplineName )
            foreach( reasons in ziplines.state.errorReason )
            {
                if ( ziplines.state.errorReason.len() == 1 ) printt( "// Reason         : " + reasons )
                else printt( "// Reasons       "  + reasonNum++ + ": " + reasons )
            }
            foreach( reasons in ziplines.state.errorMinorReason )
            {
                if ( ziplines.state.errorMinorReason.len() == 1 ) printt( "// Minor reason   : " + reasons )
                else printt( "// Minor reasons "  + reasonMinorNum++ + ": " + reasons )
            }
            printt( "//" ) ; reasonNum = 1 ; reasonMinorNum = 1
        }
        printt( "//----------------------------------" )
    }
}


entity function CreateZiplinePath( ZiplineUtility zipline, vector origin, string entityType, string pointname, string NextKey, bool end )
{
    KVFilesSettings settings = zipline.settings

    entity rope = CreateEntity( entityType )
    SetTargetName( rope, pointname )
    rope.kv.MoveSpeed                   = 64
    rope.kv.Slack                       = 0
    rope.kv.Subdiv                      = 0
    rope.kv.Width                       = settings.width
    rope.kv.Type                        = "0"
    rope.kv.TextureScale                = "1"
    rope.kv.RopeMaterial                = settings.material
    rope.kv.PositionInterpolator        = 2
    rope.kv.perfect_circular_rotation   = 1
    rope.kv.Zipline                     = 1
    rope.kv.ZiplineAutoDetachDistance   = settings.startAutoDetachDistance
    rope.kv.ZiplineSagEnable            = settings.enableSag
    rope.kv.ZiplineSagHeight            = settings.sagHeight
    if( !end ) rope.kv.NextKey = NextKey
    rope.SetOrigin( origin )

    return rope
}


entity function Zipline_CreateProp( asset a, vector pos, vector ang, bool addTrigger = false )
{
    entity prop = CreatePropDynamic( a, pos, ang, SOLID_VPHYSICS, 20000 )
    prop.AllowMantle()
    int realm = -1
    if ( realm > -1 ) { prop.RemoveFromAllRealms() ; prop.AddToRealm( realm ) }
    prop.e.gameModeId = realm

    if ( addTrigger )
    {
        entity trigger = CreateEntity( "trigger_cylinder" )
    	trigger.SetRadius( 100 )
    	trigger.SetAboveHeight( 80 )
    	trigger.SetBelowHeight( 80 )
    	trigger.SetOrigin( PositionOffsetFromEnt( prop, -4, -55.5, -12 ) )
        trigger.SetEnterCallback( TouchingTriggerEnter )
        trigger.SetLeaveCallback( TouchingTriggerLeave )
        trigger.SetScriptName( TRIGGER_ZIPLINE_SCRIPT_NAME )
        DispatchSpawn( trigger )

        trigger.SetParent( prop )
    }

return prop }


void function TouchingTriggerEnter( entity trigger, entity ent )
{
    entity arm = trigger.GetParent()

    if ( IsValid( ent ) ) // ensure the entity is valid
	{
		if ( ent.IsPlayer() && ent.GetPhysics() != MOVETYPE_NOCLIP && ent.IsZiplining() ) // Noclip players are not affected by the trigger
		{
            if ( IsValid( arm ) ) arm.kv.solid = 0
		}
	}
}

void function TouchingTriggerLeave( entity trigger, entity ent )
{
    entity arm = trigger.GetParent()

    if ( IsValid( arm ) ) arm.kv.solid = SOLID_VPHYSICS
}
